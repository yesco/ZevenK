# Reads a simple keysequence/chord mapping
# to words and outputs it as a json mapping
#
# The format of the input data is:
#
#   KEYBK\tWORD( WORD..)
#
#   WORD
#
# Example:
#
#   fdsg	fish
#   adg		act pet pin pen pit zen pig
#
#   abracadabra
#   Paris
#
# And the corresponding output:
#
#   let keybm = {
#     "fdsg": ["fish"],
#     "adg": ["act", "pet", "pin", "pen", "pit", "zen", "pig"],
#     "agfadadfagfa": "abracadabra",
#     "aafds": "Paris",
#     ...
#   }
#
# TODO: possible for enbedded devices
# the oiutput should be sorted on keybk.

# If there are several matches,
# it's proposeed that the keyboard program
# will give the user choices.
# Disambigution should strive for simple:
#
#   adg=Act/pEt/pIn/peN/piT/Zen/piG
#   adg=a-act,s-pet,d-pin,f-pen,g-pit,z-zen,g-pig (not so good but easier typing?)
#
# (i.e. find unique character to select
#  one, highlight (not bold, lol)
#
# # lines starting with # or // are
# commented using // .

# seen asdfg:s
my %seen; 
# if the asdfg allows allows addisions
my %addingok;




print "// Generated by 'mk-json.pl @ARGV\n";

$iso = `date -u --iso=s`;
chop($iso);
print "// at $iso UTC\n";

$iso = `date --iso=s`;
chop($iso);
print "// at $iso local\n";

print "\nlet keybm = {\n";

sub qt {
    my ($s) = @_;
    #print STDERR "s=$s<\n";
    $s =~ s/([\'\"\\])/\\$1/g;
    $s = '"'. $s.'"';
    #print STDERR "s=$s<\n";
    return $s;
}

my %filedone;
my $lastfile;
while(<>) {
    my $orig = $_;
    
    # skip duplicate file
    # (this allows "foo.lst *.lst")
    while($filedone{$ARGV} && <>) {
	#print STDERR "%% $. skipping $ARGV\n";
    }
    
    # print file name as delimiter
    if (!($lastfile eq $ARGV)) {
	print "\n  // File: $ARGV\n";
	$filedone{$lastfile} = 1;
	$lastfile = $ARGV;
    }

	
    # comments
    if (s/^#+ ?// || s://::) {
	print "  // $_";
	next;
    }

    # remove comments at end of line
    # (TODO: .hash	"#"    ....
    s/#+.*$//;

    # + asdfg\tword... # allow add
    my $addok = 0;
    $addok = 1 if s/^+ //;

    # keycombo line
    if (s/^(\S+)[\t\s]+//) {
	my $keyb = $1;
	$addingok{$keyb} = 1 if $addok;
	my @words = m/(\S+)/g;

	if (!$addingok{$keyb} &&$seen{$keyb}) {
	    print STDERR "%% $ARGV: '$keyb' conflicting def: $orig";
	    # TODO: append? maybe for plain
	    next;
	}
	$seen{$keyb} = 1;
	    
	print "  \"$keyb\": [" .
	    join(", ",
		 map {qt($_)} @words),
	    "],\n";
	next;
    }

    # dictionary entry
    # TODO: maybe remove?
    # TODO: require earlier expansion
    if (m/^(\S+)$/) {
	my $word = $1;
	my $keyb = $word;
	$keyb =~ s/[qazpo]/a/ig;
	$keyb =~ s/[wsxol]/s/ig;
	$keyb =~ s/[edcik]/d/ig;
	$keyb =~ s/[rfvujm]/f/ig;
	$keyb =~ s/[tgbyhn]/g/ig;
	# TOOD: phrasees
	$keyb =~ s/ /_/g;

	if (!$addingok{$keyb} &&$seen{$keyb}) {
	    print STDERR "%% $ARGV: '$keyb' conflicting def: $orig";
	    # TODO: append? at least for dict?
	    next;
	}
	$seen{$keyb} = 1;
	    
	print "  \"$keyb\": ".qt($word),",\n";
	next;
    }

    # skip empty lines
    next if /^$/;
    
    # no match - complain
    print STDERR "%% File $ARGV - unparsed line $_";
}

print "\n};\n";
