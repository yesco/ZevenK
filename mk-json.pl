# Reads a simple keysequence/chord mapping
# to words and outputs it as a json mapping
#
# The format of the input data is:
#
#   KEYBK\tWORD( WORD..)
#
#   WORD
#
# Example:
#
#   fdsg	fish
#   adg		act pet pin pen pit zen pig
#
#   abracadabra
#   Paris
#
# And the corresponding output:
#
#   let keybm = {
#     "fdsg": ["fish"],
#     "adg": ["act", "pet", "pin", "pen", "pit", "zen", "pig"],
#     "agfadadfagfa": "abracadabra",
#     "aafds": "Paris",
#     ...
#   }
#
# TODO: possible for enbedded devices
# the oiutput should be sorted on keybk.

# If there are several matches,
# it's proposeed that the keyboard program
# will give the user choices.
# Disambigution should strive for simple:
#
#   adg=Act/pEt/pIn/peN/piT/Zen/piG
#   adg=a-act,s-pet,d-pin,f-pen,g-pit,z-zen,g-pig (not so good but easier typing?)
#
# (i.e. find unique character to select
#  one, highlight (not bold, lol)
#
# # lines starting with # or // are
# commented using // .

my %seen;

print "// Generated by 'mk-json.pl @ARGV\n";

$iso = `date -u --iso=s`;
chop($iso);
print "// at $iso UTC\n";

$iso = `date --iso=s`;
chop($iso);
print "// at $iso local\n";

print "\nlet keybm = {\n";

my $lastfile;
while(<>) {
    # print file name as delimiter
    if (!($lastfile eq $ARGV)) {
	print "\n  // File: $ARGV\n";
	$lastfile = $ARGV;
    }

    # comments
    if (s/^#+ ?// || s://::) {
	print "  // $_";
	next;
    }

    # keycombo line
    if (s/^(\S+)[\t\s]+//) {
	my $keyb = $1;
	my @words = m/(\w+)/g;

	if ($seen{$keyb}) {
	    print STDERR "%% $ARGV: '$keyb' conflicts def:$_";
	    # TODO: append? maybe for plain
	    next;
	}
	$seen{$keyb} = 1;
	    
	print "  \"$keyb\": [" .
	    join(", ",
		 map { "\"$_\"" } @words),
	    "],\n";
	next;
    }

    # dictionary entry
    if (m/^(\S+)$/) {
	my $word = $1;
	my $keyb = $word;
	$keyb =~ s/[qazpo]/a/ig;
	$keyb =~ s/[wsxol]/s/ig;
	$keyb =~ s/[edcik]/d/ig;
	$keyb =~ s/[rfvujm]/f/ig;
	$keyb =~ s/[tgbyhn]/g/ig;
	# TOOD: phrasees
	$keyb =~ s/ /_/g;

	if ($seen{$keyb}) {
	    print STDERR "%% $ARGV: '$keyb' conflicts def: $_";
	    # TODO: append? at least for dict?
	    next;
	}
	$seen{$keyb} = 1;
	    
	print "  \"$keyb\": \"$word\",\n";
	next;
    }

    # skip empty lines
    next if /^$/;
    
    # no match - complain
    print STDERR "%% File $ARGV - unparsed line $_";
}

print "};\n";

